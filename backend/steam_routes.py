from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel, Field
from typing import Dict, Optional
from auth import require_moderator, require_auth
from docker_manager import DockerManager, DEFAULT_STEAM_PORT_START
from config import SERVERS_ROOT
from pathlib import Path
import subprocess
import os
import random
import string
import json
import logging

from steam_games import STEAM_GAMES

router = APIRouter(prefix="/steam", tags=["steam"])


logger = logging.getLogger(__name__)

def _random_password(length: int = 12) -> str:
    alphabet = string.ascii_letters + string.digits
    return "".join(random.choice(alphabet) for _ in range(length))


def _make_dir_writable(path: Path) -> None:
    """Ensure the directory exists and is writable by unprivileged users."""

    path.mkdir(parents=True, exist_ok=True)
    if os.name == "nt":
        try:
            subprocess.run(
                [
                    "icacls",
                    str(path),
                    "/grant",
                    "Everyone:(OI)(CI)F",
                    "/T",
                    "/C",
                ],
                check=False,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
        except Exception:
            pass
    else:
        try:
            path.chmod(0o777)
        except Exception:
            pass
        try:
            os.chown(path, 1000, 1000)
        except PermissionError:
            pass
        except AttributeError:
            # On some Python builds os.chown may not exist
            pass
        except Exception:
            pass


class SteamInstallRequest(BaseModel):
    game: str = Field(..., description="Game slug, e.g. palworld, valheim")
    name: str = Field(..., description="Container/server name")
    host_port: Optional[int] = Field(None, description="Preferred host port for the primary game port")
    env: Dict[str, str] | None = None


def _prepare_tmodloader_files(
    host_dir: Path,
    env: Dict[str, str],
    ports: list[dict],
    container_mount: str | None,
) -> None:
    """Create serverconfig.txt for tModLoader and align environment overrides."""

    mount_path = (container_mount or "/config").strip() or "/config"
    if not mount_path.startswith("/"):
        mount_path = f"/{mount_path}"
    mount_path = mount_path.rstrip("/") or "/config"

    world_name = (env.get("WORLD_NAME") or "Dedicated").strip() or "Dedicated"

    raw_filename = (env.get("WORLD_FILENAME") or "Dedicated.wld").strip()
    if not raw_filename:
        raw_filename = "Dedicated.wld"
    if not raw_filename.lower().endswith(".wld"):
        raw_filename = f"{raw_filename}.wld"

    env["WORLD_NAME"] = world_name
    env["WORLD_FILENAME"] = raw_filename
    env.setdefault("MAX_PLAYERS", "8")
    env.setdefault("WORLD_SIZE", "3")
    env.setdefault("WORLD_DIFFICULTY", "1")
    env.setdefault("WORLD_SEED", "")

    # Only pass the lowercase world env when the file already exists; otherwise let autocreate generate it.
    if (host_dir / raw_filename).exists():
        env["world"] = raw_filename
    else:
        env.pop("world", None)

    # Resolve the container port we expose (defaults to 7777).
    port_value = "7777"
    for item in ports or []:
        try:
            c_port = item.get("container")
            if c_port is None:
                continue
            port_int = int(c_port)
            if port_int > 0:
                port_value = str(port_int)
                break
        except Exception:
            continue

    def _coerce_int_str(value: object, default: str) -> str:
        try:
            raw = str(value).strip()
            if not raw:
                return default
            int(raw)  # Validate it is numeric
            return raw
        except Exception:
            return default

    config_values = {
        "world": f"{mount_path}/{raw_filename}",
        "worldpath": mount_path,
        "worldname": world_name,
        "maxplayers": _coerce_int_str(env.get("MAX_PLAYERS"), "8"),
        "autocreate": _coerce_int_str(env.get("WORLD_SIZE"), "3"),
        "difficulty": _coerce_int_str(env.get("WORLD_DIFFICULTY"), "1"),
        "seed": env.get("WORLD_SEED", ""),
        "port": port_value,
        "password": env.get("SERVER_PASSWORD")
        or env.get("SERVER_PASS")
        or env.get("PASSWORD")
        or "",
        "language": env.get("LANGUAGE") or "en-US",
        "motd": env.get("MOTD") or "Welcome to the server!",
    }

    config_path = host_dir / "serverconfig.txt"
    try:
        lines = [
            "# Autogenerated by Minecraft-Controller",
            "# Adjust values in the Templates UI and re-provision to update this file.",
        ]
        for key, value in config_values.items():
            value_text = "" if value is None else str(value)
            lines.append(f"{key}={value_text}")
        config_path.write_text("\n".join(lines) + "\n", encoding="utf-8")
    except Exception as exc:
        logger.warning("Failed to write tModLoader config %s: %s", config_path, exc)

    # Ensure banlist exists so the container does not recreate defaults noisily.
    try:
        (host_dir / "banlist.txt").touch(exist_ok=True)
    except Exception:
        pass

@router.get("/games")
async def list_games(
    limit: int = 9,
    offset: int = 0,
    include_all: bool = False,
    current_user=Depends(require_auth),
):
    games: list[dict] = []
    items = list(STEAM_GAMES.items())
    if not include_all:
        if offset < 0:
            offset = 0
        items = items[offset: offset + limit if limit > 0 else None]
    else:
        if offset > 0:
            items = items[offset:]
    for slug, meta in items:
        env_defaults = {}
        for key, value in (meta.get("env") or {}).items():
            try:
                env_defaults[key] = str(value)
            except Exception:
                env_defaults[key] = value
        sanitized_ports: list[dict] = []
        for port_cfg in meta.get("ports") or []:
            sanitized_ports.append({
                "container": port_cfg.get("container"),
                "protocol": (port_cfg.get("protocol") or "tcp").lower(),
                "description": port_cfg.get("description"),
            })
        games.append({
            "slug": slug,
            "name": meta.get("display_name") or slug.replace("_", " ").title(),
            "summary": meta.get("summary") or meta.get("notes") or "",
            "notes": meta.get("notes") or "",
            "image": meta.get("image"),
            "ports": sanitized_ports,
            "env": env_defaults,
            "volume": meta.get("volume"),
            "default_name": meta.get("default_name") or slug,
            "category": meta.get("category"),
        })
    return {"games": games}


@router.post("/install")
async def install_steam_server(payload: SteamInstallRequest, current_user=Depends(require_moderator)):
    game = payload.game.lower()
    if game not in STEAM_GAMES:
        raise HTTPException(status_code=400, detail=f"Unsupported game: {game}")

    meta = STEAM_GAMES[game]
    image = meta["image"]
    ports = [dict(p) for p in (meta.get("ports") or [])]
    if not ports:
        raise HTTPException(status_code=400, detail="Game definition missing ports")

    env = {}
    for key, value in (meta.get("env") or {}).items():
        try:
            env[key] = str(value)
        except Exception:
            env[key] = value
    # Fill passwords if present and still set to placeholders
    for key in list(env.keys()):
        if isinstance(env[key], str) and env[key].lower() in {"change-me", "admin", ""}:
            env[key] = _random_password()
    if payload.env:
        for k, v in payload.env.items():
            if v is None:
                continue
            env[k] = str(v)

    # Use host_port for the first port only; others auto-assign
    if payload.host_port is not None and ports:
        try:
            ports[0]["host"] = int(payload.host_port)
        except Exception:
            pass

    server_root = SERVERS_ROOT / payload.name
    _make_dir_writable(server_root)
    host_dir = server_root

    # For remote Docker hosts (STEAM_DOCKER_HOST), use STEAM_SERVERS_HOST_ROOT
    # to specify the correct path on the remote machine where servers are stored.
    # This allows the Files panel to work correctly by keeping server data
    # accessible from both the Lynx backend and the Steam container.
    steam_host_root = (os.getenv("STEAM_SERVERS_HOST_ROOT") or "").strip()
    if steam_host_root:
        # Use the remote host path for volume mounting
        remote_host_dir = Path(steam_host_root) / payload.name
        volume_host_path = remote_host_dir
    else:
        volume_host_path = host_dir

    if game == "tmodloader":
        try:
            _prepare_tmodloader_files(host_dir, env, ports, (meta.get("volume") or {}).get("container"))
        except Exception as prep_err:
            logger.warning("Failed preparing tModLoader config for %s: %s", payload.name, prep_err)

    volume = None
    if meta.get("volume"):
        volume = {
            "host": volume_host_path,
            "container": meta["volume"].get("container") or "/config",
        }

    restart_policy = {"Name": "unless-stopped"}

    dm = DockerManager()
    try:
        result = None
        compose_error: str | None = None
        enable_casaos_app = (os.getenv("CASAOS_STEAM_CREATE_AS_APP") or "").strip().lower() in {
            "1",
            "true",
            "yes",
            "on",
        }
        if enable_casaos_app:
            try:
                result = dm.create_steam_compose_app(
                    name=payload.name,
                    image=image,
                    ports=ports,
                    env=env,
                    volume=volume,
                    restart_policy=restart_policy,
                    extra_labels={"steam.game": game},
                )
            except Exception as exc:
                compose_error = str(exc)

        if result is None:
            strict_compose = (os.getenv("CASAOS_COMPOSE_STRICT") or "").strip().lower() in {
                "1",
                "true",
                "yes",
                "on",
            }
            if strict_compose and compose_error:
                raise HTTPException(
                    status_code=500,
                    detail=f"CasaOS compose install failed (strict mode): {compose_error}",
                )
            result = dm.create_steam_container(
                name=payload.name,
                image=image,
                ports=ports,
                env=env,
                volume=volume,
                restart_policy=restart_policy,
                extra_labels={"steam.game": game},
            )
            if compose_error:
                result["casaos_compose_error"] = compose_error
        container_id = result.get("id")
        steam_ports: list[dict] = []
        meta_path = server_root / "server_meta.json"
        existing_meta: dict = {}
        if meta_path.exists():
            try:
                existing_meta = json.loads(meta_path.read_text(encoding="utf-8") or "{}")
            except Exception:
                existing_meta = {}

        try:
            for raw_key, host_port in (result.get("ports") or {}).items():
                parts = str(raw_key).split("/", 1)
                c_port = parts[0]
                proto = parts[1] if len(parts) > 1 else "tcp"
                try:
                    c_port_val = int(c_port)
                except Exception:
                    c_port_val = c_port
                steam_ports.append({
                    "container_port": c_port_val,
                    "protocol": proto.lower(),
                    "host_port": host_port,
                })
        except Exception:
            steam_ports = []

        updated_meta = {
            **existing_meta,
            "name": payload.name,
            "steam_game": game,
            "server_kind": "steam",
            "data_path": str(server_root),
            "mount_path": str(host_dir),
            "id": container_id,
            "ports": result.get("ports"),
            "steam_ports": steam_ports,
            "env": env,
        }
        if result.get("casaos_compose_error"):
            updated_meta["casaos_compose_error"] = result.get("casaos_compose_error")
        if result.get("casaos_compose_app"):
            updated_meta["casaos_compose_app"] = result.get("casaos_compose_app")
        try:
            meta_path.write_text(json.dumps(updated_meta), encoding="utf-8")
        except Exception:
            pass

        result["steam_game"] = game
        result["env"] = env
        result["server_kind"] = "steam"
        result["data_path"] = str(server_root)
        if steam_ports:
            result["steam_ports"] = steam_ports
        result["mount_path"] = str(host_dir)
        return result
    except Exception as e:
        # Cleanup directory on failure
        try:
            if server_root.exists() and not any(server_root.iterdir()):
                server_root.rmdir()
        except Exception:
            pass
        raise HTTPException(status_code=500, detail=f"Failed to start {game}: {e}")
