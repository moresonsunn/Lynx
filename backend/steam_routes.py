from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel, Field
from typing import Dict, Optional, Any
from auth import require_moderator, require_auth
from docker_manager import DockerManager, DEFAULT_STEAM_PORT_START
from config import SERVERS_ROOT
from pathlib import Path
import subprocess
import os
import random
import string
import json
import logging
import re
import configparser
import io
import time

from steam_games import STEAM_GAMES

router = APIRouter(prefix="/steam", tags=["steam"])


logger = logging.getLogger(__name__)

def _random_password(length: int = 12) -> str:
    alphabet = string.ascii_letters + string.digits
    return "".join(random.choice(alphabet) for _ in range(length))


def _make_dir_writable(path: Path, uid: int = 1000, gid: int = 1000) -> None:
    """Ensure the directory exists and is writable by unprivileged users."""

    path.mkdir(parents=True, exist_ok=True)
    if os.name == "nt":
        try:
            subprocess.run(
                [
                    "icacls",
                    str(path),
                    "/grant",
                    "Everyone:(OI)(CI)F",
                    "/T",
                    "/C",
                ],
                check=False,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
        except Exception:
            pass
    else:
        try:
            path.chmod(0o777)
        except Exception:
            pass
        try:
            os.chown(path, uid, gid)
        except PermissionError:
            pass
        except AttributeError:
            # On some Python builds os.chown may not exist
            pass
        except Exception:
            pass


class SteamInstallRequest(BaseModel):
    game: str = Field(..., description="Game slug, e.g. palworld, valheim")
    name: str = Field(..., description="Container/server name")
    host_port: Optional[int] = Field(None, description="Preferred host port for the primary game port")
    env: Dict[str, str] | None = None


def _prepare_tmodloader_files(
    host_dir: Path,
    env: Dict[str, str],
    ports: list[dict],
    container_mount: str | None,
) -> None:
    """Create serverconfig.txt for tModLoader and align environment overrides."""

    mount_path = (container_mount or "/config").strip() or "/config"
    if not mount_path.startswith("/"):
        mount_path = f"/{mount_path}"
    mount_path = mount_path.rstrip("/") or "/config"

    world_name = (env.get("WORLD_NAME") or "Dedicated").strip() or "Dedicated"

    raw_filename = (env.get("WORLD_FILENAME") or "Dedicated.wld").strip()
    if not raw_filename:
        raw_filename = "Dedicated.wld"
    if not raw_filename.lower().endswith(".wld"):
        raw_filename = f"{raw_filename}.wld"

    env["WORLD_NAME"] = world_name
    env["WORLD_FILENAME"] = raw_filename
    env.setdefault("MAX_PLAYERS", "8")
    env.setdefault("WORLD_SIZE", "3")
    env.setdefault("WORLD_DIFFICULTY", "1")
    env.setdefault("WORLD_SEED", "")

    # Only pass the lowercase world env when the file already exists; otherwise let autocreate generate it.
    if (host_dir / raw_filename).exists():
        env["world"] = raw_filename
    else:
        env.pop("world", None)

    # Resolve the container port we expose (defaults to 7777).
    port_value = "7777"
    for item in ports or []:
        try:
            c_port = item.get("container")
            if c_port is None:
                continue
            port_int = int(c_port)
            if port_int > 0:
                port_value = str(port_int)
                break
        except Exception:
            continue

    def _coerce_int_str(value: object, default: str) -> str:
        try:
            raw = str(value).strip()
            if not raw:
                return default
            int(raw)  # Validate it is numeric
            return raw
        except Exception:
            return default

    config_values = {
        "world": f"{mount_path}/{raw_filename}",
        "worldpath": mount_path,
        "worldname": world_name,
        "maxplayers": _coerce_int_str(env.get("MAX_PLAYERS"), "8"),
        "autocreate": _coerce_int_str(env.get("WORLD_SIZE"), "3"),
        "difficulty": _coerce_int_str(env.get("WORLD_DIFFICULTY"), "1"),
        "seed": env.get("WORLD_SEED", ""),
        "port": port_value,
        "password": env.get("SERVER_PASSWORD")
        or env.get("SERVER_PASS")
        or env.get("PASSWORD")
        or "",
        "language": env.get("LANGUAGE") or "en-US",
        "motd": env.get("MOTD") or "Welcome to the server!",
    }

    config_path = host_dir / "serverconfig.txt"
    try:
        lines = [
            "# Autogenerated by Minecraft-Controller",
            "# Adjust values in the Templates UI and re-provision to update this file.",
        ]
        for key, value in config_values.items():
            value_text = "" if value is None else str(value)
            lines.append(f"{key}={value_text}")
        config_path.write_text("\n".join(lines) + "\n", encoding="utf-8")
    except Exception as exc:
        logger.warning("Failed to write tModLoader config %s: %s", config_path, exc)

    # Ensure banlist exists so the container does not recreate defaults noisily.
    try:
        (host_dir / "banlist.txt").touch(exist_ok=True)
    except Exception:
        pass

# ---------------------------------------------------------------------------
# Games list cache â€“ the catalog is static at runtime so we build the
# serialised list once and reuse it on every request.
# ---------------------------------------------------------------------------
_games_cache: list[dict] | None = None
_games_cache_ts: float = 0.0
_GAMES_CACHE_TTL = 300  # seconds


def _build_games_list() -> list[dict]:
    """Build the full games list once from STEAM_GAMES catalog."""
    games: list[dict] = []
    for slug, meta in STEAM_GAMES.items():
        env_defaults = {}
        for key, value in (meta.get("env") or {}).items():
            try:
                env_defaults[key] = str(value)
            except Exception:
                env_defaults[key] = value
        sanitized_ports: list[dict] = []
        for port_cfg in meta.get("ports") or []:
            sanitized_ports.append({
                "container": port_cfg.get("container"),
                "protocol": (port_cfg.get("protocol") or "tcp").lower(),
                "description": port_cfg.get("description"),
            })
        games.append({
            "slug": slug,
            "name": meta.get("display_name") or slug.replace("_", " ").title(),
            "summary": meta.get("summary") or meta.get("notes") or "",
            "notes": meta.get("notes") or "",
            "image": meta.get("image"),
            "steam_appid": meta.get("steam_appid"),
            "game_image": meta.get("game_image"),
            "ports": sanitized_ports,
            "env": env_defaults,
            "volume": meta.get("volume"),
            "default_name": meta.get("default_name") or slug,
            "category": meta.get("category"),
            "has_game_settings": bool(meta.get("game_settings")),
        })
    return games


def _get_games_cache() -> list[dict]:
    global _games_cache, _games_cache_ts
    now = time.monotonic()
    if _games_cache is None or (now - _games_cache_ts) > _GAMES_CACHE_TTL:
        _games_cache = _build_games_list()
        _games_cache_ts = now
    return _games_cache


@router.get("/games")
async def list_games(
    limit: int = 9,
    offset: int = 0,
    include_all: bool = False,
    current_user=Depends(require_auth),
):
    all_games = _get_games_cache()
    if not include_all:
        if offset < 0:
            offset = 0
        games = all_games[offset: offset + limit if limit > 0 else None]
    else:
        games = all_games[offset:] if offset > 0 else all_games
    return {"games": games, "total": len(all_games)}


@router.post("/install")
async def install_steam_server(payload: SteamInstallRequest, current_user=Depends(require_moderator)):
    game = payload.game.lower()
    if game not in STEAM_GAMES:
        raise HTTPException(status_code=400, detail=f"Unsupported game: {game}")

    meta = STEAM_GAMES[game]
    image = meta["image"]
    ports = [dict(p) for p in (meta.get("ports") or [])]
    if not ports:
        raise HTTPException(status_code=400, detail="Game definition missing ports")

    env = {}
    for key, value in (meta.get("env") or {}).items():
        try:
            env[key] = str(value)
        except Exception:
            env[key] = value
    # Fill passwords if present and still set to placeholders
    for key in list(env.keys()):
        if isinstance(env[key], str) and env[key].lower() in {"change-me", "admin", ""}:
            env[key] = _random_password()
    if payload.env:
        for k, v in payload.env.items():
            if v is None:
                continue
            env[k] = str(v)

    # Use host_port for the first port only; others auto-assign
    if payload.host_port is not None and ports:
        try:
            ports[0]["host"] = int(payload.host_port)
        except Exception:
            pass

    server_root = SERVERS_ROOT / payload.name
    # Determine UID/GID from game env for proper directory ownership
    dir_uid = 1000
    dir_gid = 1000
    try:
        dir_uid = int(env.get("UID") or env.get("PUID") or 1000)
        dir_gid = int(env.get("GID") or env.get("PGID") or 1000)
    except (ValueError, TypeError):
        pass
    _make_dir_writable(server_root, uid=dir_uid, gid=dir_gid)
    host_dir = server_root

    # For remote Docker hosts (STEAM_DOCKER_HOST), use STEAM_SERVERS_HOST_ROOT
    # to specify the correct path on the remote machine where servers are stored.
    # This allows the Files panel to work correctly by keeping server data
    # accessible from both the Lynx backend and the Steam container.
    steam_host_root = (os.getenv("STEAM_SERVERS_HOST_ROOT") or "").strip()
    if steam_host_root:
        # Use the remote host path for volume mounting
        remote_host_dir = Path(steam_host_root) / payload.name
        volume_host_path = remote_host_dir
    else:
        volume_host_path = host_dir

    if game == "tmodloader":
        try:
            _prepare_tmodloader_files(host_dir, env, ports, (meta.get("volume") or {}).get("container"))
        except Exception as prep_err:
            logger.warning("Failed preparing tModLoader config for %s: %s", payload.name, prep_err)

    volume = None
    if meta.get("volume"):
        volume = {
            "host": volume_host_path,
            "container": meta["volume"].get("container") or "/config",
        }

    restart_policy = {"Name": "unless-stopped"}

    dm = DockerManager()
    try:
        result = None
        compose_error: str | None = None
        enable_casaos_app = (os.getenv("CASAOS_STEAM_CREATE_AS_APP") or "").strip().lower() in {
            "1",
            "true",
            "yes",
            "on",
        }
        if enable_casaos_app:
            try:
                result = dm.create_steam_compose_app(
                    name=payload.name,
                    image=image,
                    ports=ports,
                    env=env,
                    volume=volume,
                    restart_policy=restart_policy,
                    extra_labels={"steam.game": game},
                )
            except Exception as exc:
                compose_error = str(exc)

        if result is None:
            strict_compose = (os.getenv("CASAOS_COMPOSE_STRICT") or "").strip().lower() in {
                "1",
                "true",
                "yes",
                "on",
            }
            if strict_compose and compose_error:
                raise HTTPException(
                    status_code=500,
                    detail=f"CasaOS compose install failed (strict mode): {compose_error}",
                )
            result = dm.create_steam_container(
                name=payload.name,
                image=image,
                ports=ports,
                env=env,
                volume=volume,
                restart_policy=restart_policy,
                extra_labels={"steam.game": game},
                network_mode=meta.get("network_mode"),
            )
            if compose_error:
                result["casaos_compose_error"] = compose_error
        container_id = result.get("id")
        steam_ports: list[dict] = []
        meta_path = server_root / "server_meta.json"
        existing_meta: dict = {}
        if meta_path.exists():
            try:
                existing_meta = json.loads(meta_path.read_text(encoding="utf-8") or "{}")
            except Exception:
                existing_meta = {}

        try:
            for raw_key, host_port in (result.get("ports") or {}).items():
                parts = str(raw_key).split("/", 1)
                c_port = parts[0]
                proto = parts[1] if len(parts) > 1 else "tcp"
                try:
                    c_port_val = int(c_port)
                except Exception:
                    c_port_val = c_port
                steam_ports.append({
                    "container_port": c_port_val,
                    "protocol": proto.lower(),
                    "host_port": host_port,
                })
        except Exception:
            steam_ports = []

        updated_meta = {
            **existing_meta,
            "name": payload.name,
            "steam_game": game,
            "server_kind": "steam",
            "data_path": str(server_root),
            "mount_path": str(host_dir),
            "id": container_id,
            "ports": result.get("ports"),
            "steam_ports": steam_ports,
            "env": env,
        }
        if result.get("casaos_compose_error"):
            updated_meta["casaos_compose_error"] = result.get("casaos_compose_error")
        if result.get("casaos_compose_app"):
            updated_meta["casaos_compose_app"] = result.get("casaos_compose_app")
        try:
            meta_path.write_text(json.dumps(updated_meta), encoding="utf-8")
        except Exception:
            pass

        result["steam_game"] = game
        result["env"] = env
        result["server_kind"] = "steam"
        result["data_path"] = str(server_root)
        if steam_ports:
            result["steam_ports"] = steam_ports
        result["mount_path"] = str(host_dir)
        return result
    except Exception as e:
        # Cleanup directory on failure
        try:
            if server_root.exists() and not any(server_root.iterdir()):
                server_root.rmdir()
        except Exception:
            pass
        raise HTTPException(status_code=500, detail=f"Failed to start {game}: {e}")


# ---------------------------------------------------------------------------
# Game Settings helpers
# ---------------------------------------------------------------------------

def _resolve_server_dir(server_name: str) -> Path:
    """Resolve the host directory for a server by name or container ID.

    Lookup order:
    1. Direct match under SERVERS_ROOT
    2. Scan server_meta.json files for matching id or name
    3. Ask Docker for the container's volume mount source
    """
    direct = SERVERS_ROOT / server_name
    if direct.exists():
        return direct
    # Try to find by reading server_meta.json files
    if SERVERS_ROOT.exists():
        for child in SERVERS_ROOT.iterdir():
            meta_path = child / "server_meta.json"
            if meta_path.exists():
                try:
                    meta = json.loads(meta_path.read_text(encoding="utf-8") or "{}")
                    if meta.get("id", "").startswith(server_name) or meta.get("name") == server_name:
                        return child
                except Exception:
                    pass
    # Fallback: inspect Docker container for mount source
    try:
        from docker_manager import DockerManager
        dm = DockerManager()
        container = dm._get_container_any(server_name)
        mounts = (container.attrs or {}).get("Mounts", [])
        if mounts:
            source = next((m.get("Source") for m in mounts if isinstance(m, dict) and m.get("Source")), None)
            if source:
                p = Path(source)
                if p.exists():
                    return p
        # Also try SERVERS_ROOT / container.name
        name_dir = SERVERS_ROOT / container.name
        if name_dir.exists():
            return name_dir
    except Exception:
        pass
    return direct


def _detect_game_slug(server_name: str) -> str | None:
    """Detect the game slug for a server.

    Lookup order:
    1. server_meta.json in the server directory
    2. Docker container label ``steam.game``
    """
    server_dir = _resolve_server_dir(server_name)
    meta_path = server_dir / "server_meta.json"
    if meta_path.exists():
        try:
            meta = json.loads(meta_path.read_text(encoding="utf-8") or "{}")
            slug = meta.get("steam_game")
            if slug:
                return slug
        except Exception:
            pass
    # Fallback: inspect Docker container labels
    try:
        from docker_manager import DockerManager
        dm = DockerManager()
        container = dm._get_container_any(server_name)
        labels = (container.attrs.get("Config", {}) or {}).get("Labels", {}) or {}
        slug = labels.get("steam.game")
        if slug:
            # Backfill server_meta.json so future lookups are faster
            try:
                server_dir.mkdir(parents=True, exist_ok=True)
                existing: dict = {}
                if meta_path.exists():
                    existing = json.loads(meta_path.read_text(encoding="utf-8") or "{}")
                existing["steam_game"] = slug
                existing.setdefault("name", container.name)
                existing.setdefault("server_kind", "steam")
                existing.setdefault("id", container.id)
                meta_path.write_text(json.dumps(existing), encoding="utf-8")
            except Exception:
                pass
            return slug
    except Exception:
        pass
    return None


def _parse_palworld_settings(content: str) -> dict:
    """Parse PalWorld's one-line ini format:
    [/Script/Pal.PalGameWorldSettings]
    OptionSettings=(Key1=Val1,Key2=Val2,...)
    """
    settings: dict = {}
    # Find OptionSettings=(...) block
    m = re.search(r'OptionSettings\s*=\s*\(([^)]*)\)', content)
    if not m:
        return settings
    inner = m.group(1)
    # Parse Key=Value pairs (values can contain quotes)
    for pair in re.finditer(r'(\w+)\s*=\s*("(?:[^"\\]|\\.)*"|[^,)]*)', inner):
        key = pair.group(1)
        val = pair.group(2).strip('"')
        settings[key] = val
    return settings


def _serialize_palworld_settings(existing_content: str, updates: dict) -> str:
    """Update PalWorld's one-line ini format with new values."""
    current = _parse_palworld_settings(existing_content)
    current.update(updates)

    pairs = []
    for k, v in current.items():
        # Booleans in PalWorld config
        if isinstance(v, bool):
            pairs.append(f"{k}={'True' if v else 'False'}")
        elif isinstance(v, str) and v.lower() in ("true", "false"):
            pairs.append(f"{k}={v}")
        else:
            pairs.append(f"{k}={v}")

    option_str = f"OptionSettings=({','.join(pairs)})"
    section = "[/Script/Pal.PalGameWorldSettings]"
    return f"{section}\n{option_str}\n"


def _parse_keyvalue_config(content: str) -> dict:
    """Parse simple key=value or key value config files (Rust server.cfg, CS2 server.cfg)."""
    settings: dict = {}
    for line in content.splitlines():
        line = line.strip()
        if not line or line.startswith("//") or line.startswith("#"):
            continue
        # Try key=value first, then key "value", then key value
        m = re.match(r'^(\S+)\s*[=]\s*"?([^"]*)"?\s*$', line)
        if not m:
            m = re.match(r'^(\S+)\s+"([^"]*)"\s*$', line)
        if not m:
            m = re.match(r'^(\S+)\s+(\S+)\s*$', line)
        if m:
            settings[m.group(1)] = m.group(2)
    return settings


def _serialize_keyvalue_config(existing_content: str, updates: dict) -> str:
    """Update key=value config, preserving comments and structure."""
    lines = existing_content.splitlines()
    updated_keys: set = set()
    result_lines: list[str] = []

    for line in lines:
        stripped = line.strip()
        if stripped and not stripped.startswith("//") and not stripped.startswith("#"):
            m = re.match(r'^(\S+)\s*[= ]\s*', stripped)
            if m and m.group(1) in updates:
                key = m.group(1)
                val = updates[key]
                if isinstance(val, bool):
                    val = "1" if val else "0"
                # Preserve format: if original had quotes, use quotes
                if '"' in stripped:
                    result_lines.append(f'{key} "{val}"')
                elif '=' in stripped:
                    result_lines.append(f'{key}={val}')
                else:
                    result_lines.append(f'{key} {val}')
                updated_keys.add(key)
                continue
        result_lines.append(line)

    # Append new keys that weren't in the file
    for key, val in updates.items():
        if key not in updated_keys:
            if isinstance(val, bool):
                val = "1" if val else "0"
            result_lines.append(f'{key} "{val}"')

    return "\n".join(result_lines) + "\n"


def _parse_env_config(content: str) -> dict:
    """Parse .env-style config files."""
    settings: dict = {}
    for line in content.splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if "=" in line:
            key, _, val = line.partition("=")
            settings[key.strip()] = val.strip().strip('"').strip("'")
    return settings


def _serialize_env_config(existing_content: str, updates: dict) -> str:
    """Update .env-style config, preserving comments."""
    lines = existing_content.splitlines()
    updated_keys: set = set()
    result_lines: list[str] = []

    for line in lines:
        stripped = line.strip()
        if stripped and not stripped.startswith("#") and "=" in stripped:
            key = stripped.split("=", 1)[0].strip()
            if key in updates:
                val = updates[key]
                if isinstance(val, bool):
                    val = "true" if val else "false"
                result_lines.append(f"{key}={val}")
                updated_keys.add(key)
                continue
        result_lines.append(line)

    for key, val in updates.items():
        if key not in updated_keys:
            if isinstance(val, bool):
                val = "true" if val else "false"
            result_lines.append(f"{key}={val}")

    return "\n".join(result_lines) + "\n"


def _parse_json_config(content: str) -> dict:
    """Parse JSON config files."""
    try:
        return json.loads(content)
    except Exception:
        return {}


def _serialize_json_config(existing_content: str, updates: dict) -> str:
    """Update JSON config, merging with existing values."""
    try:
        data = json.loads(existing_content)
    except Exception:
        data = {}
    data.update(updates)
    return json.dumps(data, indent=2) + "\n"


def _parse_ini_config(content: str, section: str | None = None) -> dict:
    """Parse standard INI config files."""
    parser = configparser.ConfigParser(strict=False)
    parser.read_string(content)
    target_section = section or (parser.sections()[0] if parser.sections() else "DEFAULT")
    settings: dict = {}
    if parser.has_section(target_section):
        for key, val in parser.items(target_section):
            settings[key] = val
    return settings


def _serialize_ini_config(existing_content: str, updates: dict, section: str | None = None) -> str:
    """Update INI config, preserving structure."""
    parser = configparser.ConfigParser(strict=False)
    parser.read_string(existing_content)
    target_section = section or (parser.sections()[0] if parser.sections() else "DEFAULT")
    if not parser.has_section(target_section):
        parser.add_section(target_section)
    for key, val in updates.items():
        if isinstance(val, bool):
            val = "True" if val else "False"
        parser.set(target_section, key, str(val))
    output = io.StringIO()
    parser.write(output)
    return output.getvalue()


def _parse_xml_7dtd(content: str) -> dict:
    """Parse 7 Days to Die serverconfig.xml format:
    <property name="ServerName" value="My Server"/>
    """
    settings: dict = {}
    for m in re.finditer(r'<property\s+name="([^"]+)"\s+value="([^"]*)"', content):
        settings[m.group(1)] = m.group(2)
    return settings


def _serialize_xml_7dtd(existing_content: str, updates: dict) -> str:
    """Update 7 Days to Die serverconfig.xml format."""
    content = existing_content
    updated_keys: set = set()
    for key, val in updates.items():
        if isinstance(val, bool):
            val = "true" if val else "false"
        pattern = re.compile(
            r'(<property\s+name="' + re.escape(key) + r'"\s+value=")([^"]*)("/>)',
            re.IGNORECASE,
        )
        new_content = pattern.sub(rf'\g<1>{val}\g<3>', content)
        if new_content != content:
            updated_keys.add(key)
            content = new_content
    return content


def _read_game_settings(server_dir: Path, game_slug: str) -> dict:
    """Read current game settings from the config file."""
    game_meta = STEAM_GAMES.get(game_slug, {})
    gs = game_meta.get("game_settings")
    if not gs:
        return {"error": "No game settings defined for this game", "settings": {}, "schema": []}

    config_path = server_dir / gs["config_file"]
    fmt = gs.get("config_format", "keyvalue")
    schema = gs.get("settings", [])

    current: dict = {}
    if config_path.exists():
        try:
            content = config_path.read_text(encoding="utf-8")
        except Exception:
            content = ""

        if fmt == "ini-oneline":
            current = _parse_palworld_settings(content)
        elif fmt == "keyvalue":
            current = _parse_keyvalue_config(content)
        elif fmt == "env":
            current = _parse_env_config(content)
        elif fmt == "json":
            current = _parse_json_config(content)
        elif fmt == "ini":
            current = _parse_ini_config(content, gs.get("config_section"))
        elif fmt == "xml-7dtd":
            current = _parse_xml_7dtd(content)

    # Build result with defaults filled in
    values: dict = {}
    for field in schema:
        key = field["key"]
        raw_val = current.get(key)
        if raw_val is not None:
            # Coerce to the proper type
            if field["type"] == "float":
                try:
                    raw_val = float(raw_val)
                except Exception:
                    raw_val = field.get("default")
            elif field["type"] == "int":
                try:
                    raw_val = int(float(raw_val))
                except Exception:
                    raw_val = field.get("default")
            elif field["type"] == "bool":
                if isinstance(raw_val, str):
                    raw_val = raw_val.lower() in ("true", "1", "yes", "on")
            values[key] = raw_val
        else:
            values[key] = field.get("default")

    return {
        "settings": values,
        "schema": schema,
        "config_file": gs["config_file"],
        "config_exists": config_path.exists(),
    }


def _write_game_settings(server_dir: Path, game_slug: str, updates: dict) -> dict:
    """Write updated game settings to the config file."""
    game_meta = STEAM_GAMES.get(game_slug, {})
    gs = game_meta.get("game_settings")
    if not gs:
        return {"error": "No game settings defined for this game"}

    config_path = server_dir / gs["config_file"]
    fmt = gs.get("config_format", "keyvalue")
    section = gs.get("config_section")

    # Ensure parent directory exists
    config_path.parent.mkdir(parents=True, exist_ok=True)

    existing_content = ""
    if config_path.exists():
        try:
            existing_content = config_path.read_text(encoding="utf-8")
        except Exception:
            existing_content = ""

    # Type-coerce updates based on schema
    schema = {f["key"]: f for f in gs.get("settings", [])}
    coerced: dict = {}
    for key, val in updates.items():
        field = schema.get(key)
        if not field:
            coerced[key] = val
            continue
        try:
            if field["type"] == "float":
                coerced[key] = float(val)
            elif field["type"] == "int":
                coerced[key] = int(float(val))
            elif field["type"] == "bool":
                if isinstance(val, str):
                    coerced[key] = val.lower() in ("true", "1", "yes", "on")
                else:
                    coerced[key] = bool(val)
            else:
                coerced[key] = str(val)
        except Exception:
            coerced[key] = val

    if fmt == "ini-oneline":
        new_content = _serialize_palworld_settings(existing_content, coerced)
    elif fmt == "keyvalue":
        new_content = _serialize_keyvalue_config(existing_content, coerced)
    elif fmt == "env":
        new_content = _serialize_env_config(existing_content, coerced)
    elif fmt == "json":
        new_content = _serialize_json_config(existing_content, coerced)
    elif fmt == "ini":
        new_content = _serialize_ini_config(existing_content, coerced, section)
    elif fmt == "xml-7dtd":
        new_content = _serialize_xml_7dtd(existing_content, coerced)
    else:
        return {"error": f"Unknown config format: {fmt}"}

    try:
        config_path.write_text(new_content, encoding="utf-8")
    except Exception as e:
        return {"error": f"Failed to write config: {e}"}

    return {"success": True, "config_file": gs["config_file"]}


# ---------------------------------------------------------------------------
# Game Settings API endpoints
# ---------------------------------------------------------------------------

@router.get("/games/{game_slug}/settings-schema")
async def get_game_settings_schema(game_slug: str, current_user=Depends(require_auth)):
    """Return the settings schema for a specific game."""
    game_slug = game_slug.lower()
    if game_slug not in STEAM_GAMES:
        raise HTTPException(status_code=404, detail=f"Unknown game: {game_slug}")
    meta = STEAM_GAMES[game_slug]
    gs = meta.get("game_settings")
    if not gs:
        return {"has_settings": False, "schema": [], "game": game_slug}
    return {
        "has_settings": True,
        "schema": gs.get("settings", []),
        "config_file": gs.get("config_file"),
        "config_format": gs.get("config_format"),
        "game": game_slug,
        "display_name": meta.get("display_name", game_slug),
    }


class GameSettingsUpdate(BaseModel):
    settings: Dict[str, Any] = Field(..., description="Key-value pairs of settings to update")


@router.get("/server/{server_name}/settings")
async def get_server_game_settings(server_name: str, game: str | None = None, current_user=Depends(require_auth)):
    """Read current game settings for a running server.

    The frontend may pass ``?game=palworld`` so detection is not needed.
    """
    game_slug = game or _detect_game_slug(server_name)
    if not game_slug:
        raise HTTPException(status_code=404, detail="Cannot detect game type for this server")

    server_dir = _resolve_server_dir(server_name)
    if not server_dir.exists():
        raise HTTPException(status_code=404, detail=f"Server directory not found: {server_name}")

    result = _read_game_settings(server_dir, game_slug)
    result["game"] = game_slug
    result["display_name"] = STEAM_GAMES.get(game_slug, {}).get("display_name", game_slug)
    return result


@router.put("/server/{server_name}/settings")
async def update_server_game_settings(
    server_name: str,
    payload: GameSettingsUpdate,
    game: str | None = None,
    current_user=Depends(require_moderator),
):
    """Update game settings for a server. Requires a restart to apply.

    For Docker images that regenerate configs from env vars on startup
    (e.g. Palworld), this also updates the container's environment
    variables so the settings survive restarts.
    """
    game_slug = game or _detect_game_slug(server_name)
    if not game_slug:
        raise HTTPException(status_code=404, detail="Cannot detect game type for this server")

    server_dir = _resolve_server_dir(server_name)
    if not server_dir.exists():
        raise HTTPException(status_code=404, detail=f"Server directory not found: {server_name}")

    result = _write_game_settings(server_dir, game_slug, payload.settings)
    if result.get("error"):
        raise HTTPException(status_code=500, detail=result["error"])

    # ------------------------------------------------------------------
    # Sync env vars on the Docker container so images that regenerate
    # configs from env vars (e.g. Palworld) pick up the new values
    # when the container restarts.
    # ------------------------------------------------------------------
    env_synced = False
    game_meta = STEAM_GAMES.get(game_slug, {})
    gs = game_meta.get("game_settings", {})
    schema_list = gs.get("settings", [])
    env_updates: dict[str, str] = {}
    for field in schema_list:
        env_var = field.get("env_var")
        key = field["key"]
        if env_var and key in payload.settings:
            val = payload.settings[key]
            # Docker env vars are always strings
            if isinstance(val, bool):
                env_updates[env_var] = str(val).lower()
            elif isinstance(val, float):
                env_updates[env_var] = f"{val:.6f}"
            else:
                env_updates[env_var] = str(val)
    if env_updates:
        try:
            dm = DockerManager()
            container = dm._get_container_any(server_name)
            env_result = dm.update_container_env(container.id, env_updates)
            if env_result.get("error"):
                logger.warning(f"Env sync warning for {server_name}: {env_result['error']}")
            else:
                env_synced = True
                logger.info(f"Synced {len(env_updates)} env vars for {server_name}")
        except Exception as e:
            logger.warning(f"Could not sync env vars for {server_name}: {e}")

    return {
        "success": True,
        "message": "Settings saved. Restart the server to apply changes.",
        "config_file": result.get("config_file"),
        "game": game_slug,
        "env_synced": env_synced,
    }
